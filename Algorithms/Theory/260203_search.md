---
date: 2026-02-02 ~ 2026-02-03
tags: [Algorithms, Theory, Search]

---
# 탐색 알고리즘

## 1. 완전 탐색(Exhaustive Search)
ex) Brute Force
완전 탐색은 가능한 모든 경우의 수를 다 조사하여 문제의 해답을 찾는 방법이다. 이 방법은 구현이 간단하고 확실한 해답을 보장하지만, 경우의 수가 많아질수록 시간 복잡도가 급격히 증가하여 비효율적일 수 있다.
```python
def brute_force_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```
위의 예제는 리스트에서 특정 값을 찾기 위해 모든 요소를 순차적으로 검사하는 완전 탐색 방법을 보여준다. 시간복잡도는 O(n)이다.
## 2. 순차 탐색(Linear Search)
순차 탐색은 리스트의 처음부터 끝까지 순서대로 요소를 검사하여 원하는 값을 찾는 방법이다. 이 방법은 구현이 간단하고 작은 데이터셋에 적합하지만, 큰 데이터셋에서는 비효율적일 수 있다.
### 검색 대상이 정렬되어있지 않은 경우
```python
def linear_search_unsorted(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```
위의 예제는 정렬되지 않은 리스트에서 특정 값을 찾기 위해 모든 요소를 순차적으로 검사하는 순차 탐색 방법을 보여준다. 시간복잡도는 O(n)이다.
### 검색 대상이 정렬되어있는 경우
```python
def linear_search_sorted(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
        elif arr[i] > target:
            return -1
    return -1
```
정렬되어있는 경우에는 자료를 순차적으로 검색하며, 원소의 키 값이 검색 키보다 크면 검색을 중단할 수 있다. 시간복잡도는 O(n)이다.
## 3. 이진 탐색(Binary Search)
이진 탐색은 <span style="color:red;">정렬된 리스트</span>에서 중간 값을 기준으로 검색 범위를 절반씩 줄여가며 원하는 값을 찾는 방법이다. 이 방법은 매우 효율적이다.
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

## n. 탐욕 알고리즘(Greedy Algorithm)
탐욕 알고리즘은 매 단계에서 가장 최적이라고 생각되는 선택을 하는 방법이다. 이 방법은 전체 문제를 해결하는 데 항상 최적의 해답을 보장하지는 않지만, 많은 경우에 효율적인 해답을 제공한다.
```python
def greedy_coin_change(coins, amount):
    coins.sort(reverse=True)
    count = 0
    for coin in coins:
        while amount >= coin:
            amount -= coin
            count += 1
    return count
```
위의 예제는 거스름돈 문제에서 가장 큰 단위의 동전을 우선적으로 사용하는 탐욕 알고리즘을 보여준다. 시간복잡도는 O(n log n)이다.