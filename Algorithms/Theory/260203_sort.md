---
date: 2026-02-02 ~ 2026-02-03
tags: [Algorithms, Theory, Sort]

---
# Sort Algorithms
정렬 알고리즘은 주어진 데이터 집합을 특정 순서에 따라 배열하는 방법을 의미합니다. 이 문서에서는 몇 가지 대표적인 정렬 알고리즘 및 알고리즘별 가지고 있는 시간복잡도를 소개합니다.

## 1. Bubble Sort
### 시간복잡도 : O(n^2)
인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```
반복문이 두개 중첩되어 있어 시간복잡도는 O(n^2) 이다.
## 2. Counting Sort
### 시간복잡도 : O(n + k)
특정 범위 내의 정수 데이터를 효율적으로 정렬하는 알고리즘
```python
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    sorted_arr = []
    for i in range(len(count)):
        sorted_arr.append(i * count[i])
    
    return sorted_arr
```
Counting Sort는 입력 데이터의 최대값을 k라고 할 때, 시간복잡도는 O(n + k) 이다. 따라서 k가 n에 비해 매우 클 경우 비효율적일 수 있다.

## 3. Merge Sort
## 4. Insertion Sort
## 5. Selection Sort
### 시간복잡도 : O(n^2)
주어진 리스트를 부분적으로 정렬된 상태로 유지하며, 새로운 원소를 적절한 위치에 삽입하는 방식
### 정렬 과정
1. 주어진 리스트에서 최솟값을 검색
2. 최솟값을 맨 앞의 원소와 교환
3. 맨 앞의 원소를 제외한 나머지 리스트에 대해 1~2 과정을 반복
```python
def insertion_sort(lst):
    for i in range(len(lst)):
        m = min(lst[i:])
        min_here = lst.index(m, i)
        lst[i], lst[min_here] = lst[min_here], lst[i]
    return lst
```
## 6. Quick Sort