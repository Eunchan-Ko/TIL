---
date: 2026-02-26
tags: [DP, calculation]
title: 백준 11659번 - 구간 합 구하기 4

---
# 백준 11659번 - 구간 합 구하기 4
## 문제
[11659번 - 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)
수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.
## 내가 푼 아이디어
1. 원래 단순히 계산을 통해 구간합을 구하는 방식으로 풀이하려고 했음.
2. 하지만 이 방식은 시간 복잡도가 O(nm)으로 비효율적임.

renewal idea
1. 0번 인덱스부터 i번째 인덱스까지의 구간합을 미리 계산해서 저장해두고,
2. 구간합을 구할 때는 미리 계산된 구간합을 이용해 1번의 연산으로 구간합을 구할 수 있도록 풀이함.
3. 이런걸 누적합 알고리즘이라고 부르더라.
```python
import sys
input = sys.stdin.readline
# 그냥은 입력이 느려서인지 시간초과가 났음.
n, m = map(int, input().split())
arr_n = list(map(int, input().split()))
sum_n = [0] * (n + 1)
sum_n[0] = 0
# 누적합 미리 계산
for i in range(1, n + 1):
  sum_n[i] = arr_n[i-1] + sum_n[i-1]
# 구간합 계산.
for _ in range(m):
  i, j = map(int, input().split())
  answer = sum_n[j] - sum_n[i-1]
  print(answer)
```

이 방식은 누적합을 미리 계산해두기 때문에, 구간합을 구할 때는 O(1)의 시간 복잡도로 구간합을 구할 수 있음. 따라서 전체적으로 O(n + m)의 시간 복잡도로 풀이할 수 있음.
## 더 나은 아이디어 정리
1. 누적합 알고리즘을 이용해서 구간합을 구하는 방식으로 풀이할 수 있음.
2. 누적합 알고리즘은 구간합을 구할 때 O(1)의 시간 복잡도로 구간합을 구할 수 있기 때문에, 전체적으로 O(n + m)의 시간 복잡도로 풀이할 수 있음.
